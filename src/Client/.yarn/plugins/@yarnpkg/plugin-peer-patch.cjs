/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-peer-patch",
factory: function (require) {
var plugin=(()=>{var D=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var y=Object.prototype.hasOwnProperty;var h=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+r+'" is not supported')});var F=(r,e)=>{for(var t in e)D(r,t,{get:e[t],enumerable:!0})},w=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of b(e))!y.call(r,o)&&o!==t&&D(r,o,{get:()=>e[o],enumerable:!(n=O(e,o))||n.enumerable});return r};var C=r=>w(D({},"__esModule",{value:!0}),r);var E={};F(E,{default:()=>B,protocol:()=>R});var x=h("@yarnpkg/core");var s=h("@yarnpkg/core");var U=";",j=/^([^:]*)(?::(.*))?$/,H=["","-"],W="unknown",d="",z="*";function P(r){return r.range.startsWith(R)}function m(r){return r.reference.startsWith(R)}function v(r,e,t){let n=e.devDependencies.get(t.identHash)??e.dependencies.get(t.identHash)??s.structUtils.makeDescriptor(t,d),o=r.normalizeDependency(n).range,c=L(t.range,o);return s.structUtils.makeDescriptor(t,c)}function p(r){return s.structUtils.parseRange(r).source}function L(r,e){let t=s.structUtils.parseRange(r);return t.source=e,s.structUtils.makeRange(t)}function k(r){let e=p(r);return s.structUtils.parseRange(e).selector===d}function M(r){return s.structUtils.parseRange(r).selector.split(U).map(n=>{let[o,c,i]=n.match(j),l=s.structUtils.parseDescriptor(c),a=H.includes(i)?null:s.structUtils.parseDescriptor(i??c);return a?.range===W&&(a=s.structUtils.makeDescriptor(a,z)),{source:l,target:a}})}var g=class{supports(e,t){return m(e)}getLocalPath(e,t){return null}async fetch(e,t){let n=p(e.reference),o=x.structUtils.makeLocator(e,n);return await t.fetcher.fetch(o,t)}};var u=h("@yarnpkg/core");var f=class{supportsDescriptor(e,t){return P(e)}supportsLocator(e,t){return m(e)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,n){let o=n.project.tryWorkspaceByLocator(t)??n.project.topLevelWorkspace;return v(n.project.configuration,o.manifest,e)}getResolutionDependencies(e,t){let n=p(e.range),o=u.structUtils.makeDescriptor(e,n);return{sourceDescriptor:t.project.configuration.normalizeDependency(o)}}async getCandidates(e,t,n){let o=e.range;if(k(e.range)){let i=t.sourceDescriptor;i&&(o=L(e.range,i.reference))}return[u.structUtils.makeLocator(e,o)]}async getSatisfying(e,t,n,o){return o.resolver.getSatisfying(e,t,n,o)}async resolve(e,t){let n=M(e.reference),o=p(e.reference),c=u.structUtils.makeLocator(e,o),i=await t.resolver.resolve(c,t),l=u.structUtils.renamePackage(i,e);return n.forEach(a=>{l.peerDependencies.delete(a.source.identHash),a.target&&l.peerDependencies.set(a.target.identHash,a.target)}),l}};var R="peer-patch:",S={fetchers:[g],resolvers:[f]},B=S;return C(E);})();
return plugin;
}
};
